# 01排序算法之冒泡排序

## 冒泡排序解析
  顾名思义，冒泡的意思就是对一个乱序的数组，使他们从小到大的排列，在编程里面，冒泡是比较简单的一种算法，所以经常用来教新手入门，深刻的去理解其精髓，有助于以后学习其他复杂的算法。
  
  抽象的讲解是很枯燥的，而且很难让人明白，通过一些例子，可以很简单的把这个道理阐述明白。

比如这个数组：  

    {5,2,8,9,6,1,0}
    
我想把它变成这样： 

    {0,1,2,5,6,8,9}  
    
按从小到大整齐的排列。

  对于冒泡排序算法来说，精髓就是理解数组中相邻两个数进行比较，谁小谁就放在前面，也就是往前冒。
  
  根据只有相邻两个数比较的原则，我们进行第一次全部相邻两个数之间进行比较，谁小谁站前面：
  
1:因为数组有七个数，所以相邻比较一轮需要（7-1）次  

> {**5**,**2**,8,9,6,1,0} ----- {**2**,**5**,8,9,6,1,0} //1.交换位置  
> {2,**5**,**8**,9,6,1,0} ----- {2,5,8,9,6,1,0} //2.不变  
> {2,5,**8**,**9**,6,1,0} ----- {2,5,8,9,6,1,0} //3.不变  
> {2,5,8,**9**,**6**,1,0} ----- {2,5,8,**6**,**9**,1,0} //4.交换位置  
> {2,5,8,6,**9**,**1**,0} ----- {2,5,8,6,**1**,**9**,0} //5.交换位置  
> {2,5,8,6,1,**9**,**0**} ----- {2,5,8,6,1,**0**,**9**} //6.交换位置  

2:通过一轮比较，最大的数已经沉底，可以少比较一次，所以只需要比较（7-1-1）次  
> {**2**,**5**,8,6,1,0,9} ----- {2,5,8,6,1,0,9} //不变  
> {2,**5**,**8**,6,1,0,9} ----- {2,5,8,6,1,0,9} //不变  
> {2,5,**8**,**6**,1,0,9} ----- {2,5,**6**,**8**,1,0,9} //交换  
> {2,5,6,**8**,**1**,0,9} ----- {2,5,6,**1**,**8**,0,9} //交换  
> {2,5,6,1,**8**,**0**,9} ----- {2,5,6,1,**0**,**8**,9} //交换  

3:通过上一轮比较，最大和第二大的数都已经沉底，类推，需要（7-1-2）次
> {**2**,**5**,6,1,0,8,9} ----- {2,5,6,1,0,8,9} //不变  
> {2,**5**,**6**,1,0,8,9} ----- {2,5,6,1,0,8,9} //不变  
> {2,5,**6**,**1**,0,8,9} ----- {2,5,**1**,**6**,0,8,9} //交换  
> {2,5,1,**6**,**0**,8,9} ----- {2,5,1,**0**,**6**,8,9} //交换  

4:这次就是（7-1-3）次  
> {**2**,**5**,1,0,6,8,9} ----- {2,5,1,0,6,8,9} //不变  
> {2,**5**,**1**,0,6,8,9} ----- {2,**1**,**5**,0,6,8,9} //交换  
> {2,1,**5**,**0**,6,8,9} ----- {2,1,**0**,**5**,6,8,9} //交换  

5:（7-1-4）次  
> {**2**,**1**,0,5,6,8,9} ----- {**1**,**2**,0,5,6,8,9} //交换  
> {1,**2**,**0**,5,6,8,9} ----- {1,**0**,**2**,5,6,8,9} //交换  

6:（7-1-5）次  
> {**1**,**0**,2,5,6,8,9} ----- {**0**,**1**,2,5,6,8,9} //交换

-----------
从以上分析过程，应该可以看出规律了，就是两轮嵌套的比较，第一轮外层循环要一直比较（n-1)次，而在每一轮比较过程中的内部，有会根据当前轮次而依次减少，变为（n-1-i)次 i就表示当前的轮次，取值为1~6

所以用go语言实现代码如下：

    package main
    
    import (
      "fmt"
    )
    func main(){
      a := [...]int{5, 2, 8, 9, 6, 1, 0}
	    fmt.Print("排序前的数组：")
	    fmt.Println(a)
	    num := len(a) //获得数组长度
	    var temp int  //临时变量
	    for i := 0; i < num-1; i++ { //这里表示外层循环，要循环（num-1)次
		    for j := 0; j < num-1-i; j++ { //这里表示内层，根据轮次要循环（num-1-i)次
			    if a[j] > a[j+1] { //比较大小，如果前大后小，则交换位置
				    temp = a[j]
				    a[j] = a[j+1]
				    a[j+1] = temp
			    }
			    fmt.Println(a) //每次判断后就打印结果
		    }
		    fmt.Println() //使每次内层for循环完成就换行
	    }
    
    }

-------------------

##总结  

只要理解了冒泡排序的精髓，不管什么编程语言，也不要死记硬背，只要通过自己的分析，就能够理清思路，把其变成代码。
我以前是学Java的，但是对于冒泡排序已经忘记了，我只有一点印象，好像是这个样子，然后就看见了一点别人透露的信息，那就是相邻的两个数比较，我就通过以上分析，还原了冒泡排序的代码，以此记录下来，希望能够帮助大家理解。  

  从这里也可以看出来，很多东西不需要背，只要理解含义，就可以胸有成竹，坦然面对这个知识大爆发的时代，而不会被弄得头晕脑胀。


















    
